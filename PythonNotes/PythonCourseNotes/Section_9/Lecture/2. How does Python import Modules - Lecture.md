#python #data-structures 

---
### Key Points:
- **Python imports** modules **at runtime** â³, unlike C, where it's done during compilation.
- Importing in Python is **dynamic** âš¡, while in C itâ€™s more static ğŸ”—.

---
# PART 1

## Pythonâ€™s Import Process ğŸ”
1. **Loading a Module** is straightforward, but **finding it** can be complex.
2. **System Paths** ğŸ—ºï¸: Python uses the `sys` module to determine where to find installed modules.

    ```python
    import sys
    print(sys.prefix)  # Where Python is installed
    ```

3. **Virtual Environments** ğŸ’»:
   - They change the installation prefix, allowing Python to run in isolated directories.

---

## Where Does Python Look for Imports? ğŸ‘€
- **sys.path**: A list of directories where Python looks for modules. To troubleshoot imports:
   ```python
   print(sys.path)
   ```

    ğŸ”‘ **Tip**: If a module canâ€™t be found, **check `sys.path`** to ensure the moduleâ€™s directory is listed.

- **Fun Fact**: Python can even load modules from **zip files** ğŸ—‚ï¸.

---

## The Import Process Step-by-Step ğŸ“˜
1. **Check Cache** ğŸ§ : Python checks if the module is already imported.
   - If yes, it uses the cached version, avoiding re-imports. 
   
   Example: `math` module is only loaded once, even if imported by multiple other modules.

2. **Create Module Type** ğŸ› ï¸:
   - If not in cache, Python creates a new module instance.
   - **Source code** can come from a file or other sources (e.g., zip, URLs).

3. **Compile and Execute** the module ğŸ“œ:
   - When first imported, the **module code is executed**.

---

## Example: Importing a Custom Module âœï¸

### File Structure:
- **Module file**: `module1.py`
- **Main file**: `main.py`

### Code in `module1.py`:

```python
# module1.py
print(f"Running {__name__}")

def pretty_print_dict(header, dictionary):
    print(f"\n{header}")
    for key, value in dictionary.items():
        print(f"{key}: {value}")

print("End of module1")
```

### Code in `main.py`:

```python
# main.py
print("=== Running main.py ===")
import module1
module1.pretty_print_dict("Main Globals", globals())
```

### Running the Code:
- **Output** when running `main.py`:
    - Prints `"Running main.py"`.
    - **Imports** `module1`, and the module prints its own `"Running module1"`.
    - **Uses `pretty_print_dict`** from `module1` to print global variables from `main.py`.

---

## Import Behavior âš™ï¸
1. **Importing multiple times**: Even if you import the same module again, Python wonâ€™t reload it:
   ```python
   import module1
   import module1  # No re-execution of module1 code
   ```

2. **Removing from Globals**: You can **delete the reference** to a module in your global namespace:
   ```python
   del globals()['module1']
   ```

   But the module remains cached in memory.

---

## sys.path and sys.modules ğŸ§©
- **`sys.path`**: Shows the directories Python searches for imports.
  
   ```python
   print(sys.path)
   ```

- **`sys.modules`**: Contains cached module references, so Python doesnâ€™t reload them.
  
   ```python
   print(sys.modules['module1'])
   ```

---

## Conclusion ğŸ’¡
- Python's import system is both dynamic and cache-based.
- **Important Notes**:
  - Modules run **when imported** and arenâ€™t re-executed unless explicitly done.
  - **Debugging Imports**: Use `sys.path` to check where Python is looking for modules.


---
# PART 2

## Importing Modules ğŸ› ï¸
- **Import process**:
  - When you import a module, Python **checks the cache** (i.e., `sys.modules`) ğŸ§ .
  - If the module is already in the cache, Python **returns that reference** ğŸ’¡.
  - If the module isn't cached, it creates the object in memory and adds it to the global namespace ğŸŒ.

---

### Example 2: Manipulating `sys.modules` ğŸ’»
- **Hacking `sys.modules`** to manually insert a key-value pair:
  ```python
  sys.modules['test'] = lambda: "Hello!"
  import test
  print(test())  # Output: "Hello!"
  ```
  âš ï¸ **Don't actually do this!** It's just to illustrate that Python checks `sys.modules` first.

---

## The `compile()` and `exec()` Functions ğŸ§©
- **Compilation**:
  - `compile(source_code, filename, mode)` takes **source code** and turns it into Python **bytecode** ğŸ“.
  - This bytecode can be stored as a **code object**.

- **Execution**:
  - Use `exec()` to **run the compiled code** âš™ï¸.
  - You can specify which **namespace** (e.g., `mod.__dict__`) to use during execution.

---

### Example 3: Manual Module Creation ğŸ› ï¸
1. **Directory Setup**:
   - Create two Python files: `Main.py` and `Module1_source.py`.

2. **Module1_source.py**:
   ```python
   print("Running Module1")
   def hello():
       print("Module 1 says hello!")
   ```

3. **Main.py**: Simulating module import manually:
   - **Libraries used**:
     - `os.path` for **path management** ğŸ›¤ï¸.
     - `types` for **creating module objects** ğŸ§±.
   
   - **Steps to manually import a module**:
     1. Define **module name** and **file path**.
     2. Open the file and **read its source code** ğŸ“œ.
     3. **Create a module object** using `types.ModuleType`.
     4. Set the **location** of the file with its absolute path ğŸ—ºï¸.
     5. Add the module to `sys.modules` ğŸ§©.

   - **Compile and execute the module**:
     ```python
     code_obj = compile(source_code, file_path, 'exec')
     exec(code_obj, mod.__dict__)
     ```

---

### Example Walkthrough ğŸ¯
- After executing, the module is now in `sys.modules`, allowing it to be imported normally:
  ```python
  import Module1
  Module1.hello()  # Output: "Module 1 says hello!"
  ```

### Why it Works ğŸ”
- Python **searches `sys.modules` first** during an import, so if the module is there, Python returns the reference ğŸ§­.

---

## Key Takeaways ğŸ“
- **Module imports** rely on Python's **cache** (`sys.modules`).
- `compile()` and `exec()` split **compilation** and **execution** phases of code ğŸ› ï¸.
- You can **manually create and load** modules into `sys.modules` for custom behavior ğŸ”§.


---
# PART 3

## Overview

In this part, we will take **Example 3A** and:

- âœ… Turn the importer into a **function**.
- âœ… Add a **cache lookup** step for modules before compiling and executing.

### Steps we'll follow:
1. Create a new directory, call it `example3B`.
2. Inside `example3B`, create these files:
   - `Main.py`
   - `Importer.py`
   - `module1_source.py`
   - `module2_source.py`

---

## Writing the Importer ğŸ› ï¸

### Create `importer.py`

We'll first define the function that handles module importing:

```python
def import_(module_name, module_file, module_path):
    # Define relative and absolute file paths
    # Read source code from the file
    # Create module object
    # Compile and execute the source code
    
    # Check if module already exists in cache
    if module_name in sys.modules:
        return sys.modules[module_name]  # Return from cache

    # Otherwise, create module, compile & execute
    module = ...
    return module
```

### Key Actions in `importer.py`:
- Look for the module **in the cache** first ğŸ—„ï¸.
- If found, return it.
- If not found, **create** the module and **store it** in the cache.

---

## Writing the Main Program ğŸ¯

### Create `Main.py`

In `Main.py`, we'll use our custom importer to load `module1`:

```python
import sys
import importer

module1 = importer.import_(
    "module1", 
    "module1_source.py", 
    "./"
)

print("Module 1 imported and cached")
```

- ğŸ’¡ Weâ€™re using our custom function `import_` from `importer.py` to load `module1_source.py`.

---

## Check Cache ğŸ§

To verify that `module1` is in the cache:

```python
print(sys.modules.get("module1", "Module 1 not found"))
```

- **Expected Result**: `sys.modules` should confirm that `module1` is cached.

---

## Module 2 Interactions ğŸ”„

Now letâ€™s test importing `module1` in `module2`:

### Modify `module2_source.py`:
```python
print("Running module2.py")
import module1  # Import module1

def hello():
    print("Module 2 says hello!")
    module1.hello()
```

- **Objective**: Ensure `module2` can access `module1` without reloading it.

### Update `Main.py`:
```python
import module2
module2.hello()
```

- ğŸ§© Weâ€™re using Pythonâ€™s standard import for `module2` and checking if our custom importer and the standard one are compatible.

---

## Expected Output ğŸ‘€
When running `Main.py`, we expect:

1. **First time**: `module1` is loaded and cached.
2. **Second time**: `module1` is fetched from cache (without reloading).

---

## Python's Flexible Importing ğŸ“¦

Python can load modules from various places:
- **.py files** (usual case)
- **.zip files** (Python can read from a zip archive!)
- **Databases** (though uncommon, possible with custom importers).

### Example:
```python
import sys
print(sys.path)
# Output shows paths, including any zip files (e.g., python36.zip)
```

- You can create custom importers to load code from databases, network locations, etc. (But thatâ€™s more advanced!)

---

### Recap ğŸ“

- We created a custom importer function that:
  - Checks for modules in the cache before importing.
  - Handles creating, compiling, and caching modules.
- We tested the compatibility between our custom importer and Pythonâ€™s built-in import system.

ğŸ“Œ **Key takeaway**: Module importing in Python is flexible, and understanding the cache system helps optimize your code!