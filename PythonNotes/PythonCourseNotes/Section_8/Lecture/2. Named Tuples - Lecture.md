#python #data-structures 

coding lesson notes: [[2. Named Tuples - Code]]

---
### ğŸŒŸ What Are Named Tuples?
- **Tuples** are useful for data structures, where each position in the tuple has specific meaning.
- Example: `point = (10, 20)` means the first element is the **x-coordinate** and the second is the **y-coordinate**.

### ğŸ” Accessing Tuple Data:
1. **Tuple unpacking:**
   ```python
   x, y = point  # x=10, y=20
   ```
2. **Indexing:**
   ```python
   x = point[0]  # Access first element (x-coordinate)
   y = point[1]  # Access second element (y-coordinate)
   ```
   âš ï¸ **Not readable!** You must remember the meaning of each index.

### ğŸ›ï¸ Classes for Readability
- Classes make it easier to work with **more complex** structures, e.g., a 2D point:
   ```python
   class Point2D:
       def __init__(self, x, y):
           self.x = x
           self.y = y
   ```
   ```python
   point = Point2D(x=10, y=20)
   distance = math.sqrt(point.x ** 2 + point.y ** 2)
   ```
   ğŸŒŸ **Pros of classes**:
   - Clearer code, **self-documenting**.
   - Can add methods like `__repr__`, `__eq__`.

### ğŸ¤” Downside of Classes
- More **boilerplate** code (e.g., methods for comparison, printing).
- Objects of these classes are **mutable**, while tuples are **immutable**.
- For simple cases like coordinates or stock data, a class might feel **overkill**.

---

### ğŸ¯ The Sweet Spot: **Named Tuples**
Named Tuples combine the **simplicity of tuples** with the **readability of classes**.
- **Named tuples are subclasses of tuples**, but they assign names to positions.
- They come from Pythonâ€™s `collections` module:
   ```python
   from collections import namedtuple
   ```

### ğŸ“¦ How Named Tuples Work
1. **Creating a Named Tuple Class**:
   ```python
   Point2D = namedtuple('Point2D', ['x', 'y'])
   ```
   - `Point2D` is now a class that acts like a tuple but with **named fields**.
   
2. **Instantiating the Named Tuple**:
   ```python
   p = Point2D(x=10, y=20)
   print(p.x, p.y)  # Access via name
   print(p[0], p[1])  # Access via index (still works!)
   ```

### âš¡ Why Named Tuples Rock
- **Immutable**: Like regular tuples.
- **Readable**: Access by **name** (no need to remember indices).
- **Efficient**: Named tuples are as **memory efficient** as tuples.
- **Auto-generated methods**: Includes useful methods like `__repr__` and `__eq__` automatically!

### ğŸ§‘â€ğŸ’» Example: Stock Data
Consider a **stock** with multiple attributes (symbol, open, high, low, close):
   ```python
   Stock = namedtuple('Stock', ['symbol', 'year', 'month', 'day', 'open', 'high', 'low', 'close'])
   dow_jones = Stock('DJIA', 2023, 9, 20, 34_000, 34_500, 33_800, 34_200)
   ```

- **Readable Calculation**:
   ```python
   spread = dow_jones.high - dow_jones.low
   ```
   **Without named tuples**, you'd have to remember that `high` is at index 5 and `low` is at index 6:
   ```python
   spread = dow_jones[5] - dow_jones[6]
   ```

---

### ğŸ”‘ Key Points of Named Tuples
1. **Named tuple is not a class itself**; it is a **function** that generates a new class.
2. **Syntax**:
   - You pass the **class name** and a **list of field names**:
     ```python
     Point2D = namedtuple('Point2D', ['x', 'y'])
     ```
   - Alternatively, you can pass field names as a single string:
     ```python
     Point2D = namedtuple('Point2D', 'x y')
     ```

3. **Generated class acts like a tuple**:
   - You can access via **indices** or **names**.
   - Example:
     ```python
     point = Point2D(10, 20)
     print(point.x, point[0])  # Both work!
     ```

4. **Naming convention**: We typically name the variable the **same as the class** to avoid confusion.

### ğŸ› ï¸ Using Named Tuples Efficiently
- You can use **any sequence** (list, tuple, etc.) to define field names as long as itâ€™s **ordered**.
- Named tuples enforce **valid field names** (e.g., no underscores).

### ğŸ§‘â€ğŸ’» Aliasing Example
```python
PT2D_Alias = Point2D
pt = PT2D_Alias(5, 7)
print(pt.x)  # Works the same!
```
Both names refer to the same class, so instances behave the same.

---

### ğŸ§  Conclusion
Named tuples provide:
- **Tuple immutability** ğŸ›‘,
- **Class-like readability** âœ¨,
- Automatic features for **easy development** ğŸš€.


---
# PART 2

## ğŸ·ï¸ Creating and Instantiating Named Tuples
- **Named tuples** are classes under the hood, and we can instantiate them like any class.
- The `__new__` method takes field names we provide, similar to the `__init__` method.
  
  **Example:**
  ```python
  Point2D = namedtuple('Point2D', ['x', 'y'])
  pt1 = Point2D(10, 20)
  ```
  - Instantiated using **positional** or **keyword arguments**:
    - `pt1 = Point2D(10, 20)`  
    - `pt1 = Point2D(x=10, y=20)`
  - Helps improve **readability** and **clarity** in your code! ğŸ‘

---

## ğŸ” Accessing Data in Named Tuples
### Like a Regular Tuple
- You can access data just like a regular tuple:
  - By **index**: `pt1[0]` returns `10`
  - By **iteration**:
    ```python
    for value in pt1:
        print(value)
    ```
  - By **slicing** (returns part of the tuple).

### Like a Class (Field Names)
- Named tuples allow access via **field names**:
  ```python
  pt1.x   # returns 10
  pt1.y   # returns 20
  ```
  - **Note:** Named tuples are **immutable** â€“ you canâ€™t modify values once created.
    - âŒ `pt1.x = 100` â†’ **Error!**
  - **Tuple Unpacking** is supported too:
    ```python
    x, y = pt1
    ```

---

## ğŸ” Immutability of Named Tuples
- **Named tuples are subclasses of tuples**, inheriting immutability.  
  - You **cannot change** their contents once created.  
  - But, you can point the variable to a new object.

  **Example**:  
  ```python
  pt1 = Point2D(10, 20)
  pt1.x = 100  # âŒ Wonâ€™t work! Tuples are immutable
  ```

---

## âš™ï¸ Special Features of Named Tuples
### 1. **rename** Argument
- The `rename` argument helps with **invalid field names**.
  - Default is `False`. When set to `True`, it renames invalid names using an underscore and index position.
  
  **Example:**
  ```python
  Person = namedtuple('Person', ['name', 'age', '1address'], rename=True)
  ```
  - Becomes: `name, age, _2`  
    (The `1address` gets renamed to `_2` due to invalidity.)

### 2. **Field Names with _fields**
- You can check the **field names** of a named tuple using `_fields`:
  ```python
  Person._fields  # returns ('name', 'age', '_2')
  ```

---

## ğŸ§  Introspection in Named Tuples
### Code Generation (`_source`)
- Named tuples are **class factories** â€“ they generate a class.
- You can view the generated class code using `_source`:
  ```python
  Point2D._source
  ```
  - Outputs the generated code, showing how the tuple behaves as a class.

### Practical Example (Generated Code):
```python
class Point2D(tuple):
    __slots__ = ()
    _fields = ('x', 'y')

    def __new__(cls, x, y):
        return tuple.__new__(cls, (x, y))

    def __repr__(self):
        return 'Point2D(x=%r, y=%r)' % (self.x, self.y)
```
- **`__new__`** is the key method for tuple instantiation, similar to constructors in Java.
  
---

## ğŸ› ï¸ Converting Named Tuples to Dictionaries
- You can easily convert a named tuple instance to a **dictionary** using `_asdict()`:
  ```python
  pt1 = Point2D(10, 20)
  pt1._asdict()  # {'x': 10, 'y': 20}
  ```
  - **Key**: Field names
  - **Value**: Tuple values
  
  This is useful when you need a dict representation of your tuple!