#python #general_knowledge 

---
## ğŸŸ¡ Class vs. Closure: Averager

### ğŸ¯ **Goal:**
We want an object that lets us add numbers over time and calculates the average of those numbers.

### ğŸ›ï¸ **Class Implementation:**

```python
class Averager:
    def __init__(self):
        self.numbers = []
        
    def add(self, number):
        self.numbers.append(number)
        total = sum(self.numbers)
        count = len(self.numbers)
        return total / count
```

- **Class Properties:**
  - `numbers`: Holds the list of numbers.
  - `add()`: Appends a number to `numbers`, calculates the average, and returns it.

#### âš¡ **Issues**:
- Every time we add a number, the entire sum and count are recalculated, which is inefficient.

### âœ¨ **Closure Implementation:**

```python
def averager():
    numbers = []
    
    def add(number):
        numbers.append(number)
        total = sum(numbers)
        count = len(numbers)
        return total / count
    
    return add
```

- **Similarities to Class**:
  - Both implementations store numbers, calculate totals, and return the average.
  - Multiple instances (closures or objects) can be created, each with its own state.

#### ğŸ’¡ **Key Points**:
- **No `self`**: In closures, there's no `self`, reducing complexity.
- **Encapsulation**: The local variable `numbers` is "trapped" in the closure, mimicking object properties.

---

## ğŸ› ï¸ **Optimizing with Closures: Efficient Averager**

To improve efficiency, we'll avoid recalculating the sum and count on every call.

### ğŸŒŸ **Optimized Closure**:

```python
def averager():
    total = 0
    count = 0
    
    def add(number):
        nonlocal total, count
        total += number
        count += 1
        return total / count
    
    return add
```

- **Total & Count**: We maintain running totals (`total`) and counts (`count`) instead of appending to a list.
- **`nonlocal` Keyword**: Used to modify variables from the outer function (`total` and `count`).

---

## ğŸ•‘ **Class vs. Closure: Timer**

### ğŸ¯ **Goal:**
Measure the time elapsed between consecutive calls using Pythonâ€™s `perf_counter`.

### ğŸ›ï¸ **Class Implementation:**

```python
from time import perf_counter

class Timer:
    def __init__(self):
        self.start = perf_counter()
    
    def poll(self):
        return perf_counter() - self.start
```

- **Start Time**: Recorded at the creation of the `Timer` instance.
- **Poll Method**: Returns the elapsed time.

### âœ¨ **Closure Implementation:**

```python
from time import perf_counter

def timer():
    start = perf_counter()
    
    def poll():
        return perf_counter() - start
    
    return poll
```

- **Same Behavior**: Both implementations store the `start` time and provide a `poll` function to check the elapsed time.
  
#### ğŸ¯ **Callable Class**:

We can modify the class to make it callable by overriding `__call__`.

```python
class Timer:
    def __init__(self):
        self.start = perf_counter()
    
    def __call__(self):
        return perf_counter() - self.start
```

Now, you can call the object directly:

```python
t = Timer()
t()  # Instead of t.poll()
```

---

## âš–ï¸ **Closure vs. Class: When to Use What?**

### âœ… **Use Closures When**:
- Simplicity is key.
- You want lightweight, encapsulated behavior.
- You donâ€™t need inheritance or complex object behavior.

### âœ… **Use Classes When**:
- You need inheritance or object-oriented features.
- More complex behaviors (like multiple methods) are required.

---

**ğŸ”‘ Key Takeaways**:
- Closures encapsulate behavior and state in a simple, reusable way.
- Classes provide structure and are better for complex systems, but often closures can replace them for simpler use cases.
- Consider closures for cleaner, more efficient code where appropriate.