#python #general_knowledge 

coding lesson notes: [[5. Decorator Factories - Code]]

---
### ğŸ¯ **Introduction**
- We're continuing with **decorators** and learning how to **parameterize** them.
- We've already seen how some built-in Python decorators take parameters, like:
  - `@wraps` decorator ğŸŒ€
    - Takes a function as a parameter and copies its metadata.
  - `@lru_cache` (Least Recently Used cache) ğŸ’¾
    - Can take parameters like `maxsize`, which defines the maximum cache size.

### ğŸ”‘ **Understanding the Difference**:
- These decorators (e.g., `@wraps`, `@lru_cache`) look different from the decorators we've created:
  - They involve **function calls** (e.g., `@lru_cache(maxsize=100)`).
  - Our decorators, like `@timed`, donâ€™t take parametersâ€”**no parentheses**, meaning no function call.

---

### ğŸ•°ï¸ **Recap: Timed Decorator**
- We've created a `@timed` decorator that calculates the **elapsed time** of a function.
- In this version, we tweak it to call the function **10 times** and calculate the **average elapsed time**.

```python
def timed(fn):
    def inner(*args, **kwargs):
        total_elapsed = 0
        for _ in range(10):
            start_time = time.perf_counter()
            result = fn(*args, **kwargs)
            total_elapsed += time.perf_counter() - start_time
        avg_elapsed = total_elapsed / 10
        print(f"Average Elapsed Time: {avg_elapsed}")
        return result
    return inner
```

- You can use the decorator like this:

```python
@timed
def my_func():
    # function logic
```

Or like this:

```python
my_func = timed(my_func)
```

---

### âš ï¸ **Problem: Hardcoding Values**
- âŒ **Hardcoding** the number of repetitions (e.g., `10` calls) isn't ideal.
  - We need to pass the number of repetitions as a **parameter**.

---

### ğŸ› ï¸ **Parameterizing the Decorator**
- ğŸ—ï¸ To pass parameters, we modify the `@timed` decorator to accept a `reps` parameter.

#### New Structure:
```python
def timed(reps):  # now accepts `reps` as a parameter
    def decorator(fn):  # actual decorator
        def inner(*args, **kwargs):
            total_elapsed = 0
            for _ in range(reps):  # using `reps` instead of hardcoding
                start_time = time.perf_counter()
                result = fn(*args, **kwargs)
                total_elapsed += time.perf_counter() - start_time
            avg_elapsed = total_elapsed / reps
            print(f"Average Elapsed Time: {avg_elapsed}")
            return result
        return inner
    return decorator
```

- Now, you can use this **decorator with a parameter**:
```python
@timed(10)
def my_func():
    # function logic
```

Or like this:
```python
my_func = timed(10)(my_func)
```

---

### ğŸ­ **Decorator Factory**:
- **Important:** `@timed(10)` is **not** a decorator itself, but a **decorator factory** ğŸ­.
  - Calling `timed(10)` **creates** a decorator.
  - `@timed(10)` is equivalent to `my_func = timed(10)(my_func)`.

---

### ğŸš€ **Wrap It Up**:
- ğŸ—ï¸ **Outer function** (`timed`) is a **decorator factory** that returns the actual decorator.
- ğŸ“¦ **Inner function** (now renamed `decorator`) is the **decorator** itself.
- You can still use `@wraps(fn)` inside the decorator to copy metadata.

---

### ğŸ“ **Final Version**:
```python
from functools import wraps

def timed(reps):
    def decorator(fn):
        @wraps(fn)
        def inner(*args, **kwargs):
            total_elapsed = 0
            for _ in range(reps):
                start_time = time.perf_counter()
                result = fn(*args, **kwargs)
                total_elapsed += time.perf_counter() - start_time
            avg_elapsed = total_elapsed / reps
            print(f"Average Elapsed Time: {avg_elapsed}")
            return result
        return inner
    return decorator
```

- You can now use this cleaner syntax:
```python
@timed(10)
def my_func():
    # function logic
```

---

### ğŸ”‘ **Key Takeaways**:
- ğŸ¯ **Parameterized decorators** are useful when you want flexibility in how the decorator behaves.
- ğŸ­ **Decorator factory** functions generate decorators that accept parameters.
