#python #coding-lesson 

---
## 🌟 Introduction

Named tuples offer an elegant and concise way to create immutable objects that act like both **tuples** and **classes** with named fields. They come from the **`collections`** module and are designed to reduce boilerplate code when dealing with simple data structures.

---

## 🛠️ Creating a Named Tuple vs. Class

### 🚫 **The Traditional Way (Class)**:
We might create a **class** like this for a 3D point:

```python
class Point3D:
    def __init__(self, x, y, z):
        self.x = x
        self.y = y
        self.z = z
```

- This is simple, but if you **just need a structure to hold data** (like x, y, z), named tuples provide a more efficient and readable solution!

---

### ✅ **Named Tuple Method**:
Instead of defining a class, use a **named tuple**:

```python
from collections import namedtuple

Point2D = namedtuple('Point2D', ['x', 'y'])
```

- **Named Tuple** is **immutable**: safer for passing data since it can't be changed.
- **Class Factory**: `namedtuple()` returns a new class automatically, no need to define one.

```python
point1 = Point2D(10, 20)
print(point1)  # Output: Point2D(x=10, y=20)
```

#### ⚠️ Remember:
- **Named Tuple = Class** generated by the factory.  
- Always assign the result to a **variable** with the same name for clarity!

---

## 📝 Properties of Named Tuples

### 🔍 Readability:
Named tuples automatically generate a **readable representation** of the object:
```python
# Named Tuple for 3D points
Point3D = namedtuple('Point3D', ['x', 'y', 'z'])
p1 = Point3D(10, 20, 30)
print(p1)  # Output: Point3D(x=10, y=20, z=30)
```

### ⚖️ Tuple Inheritance:
Named tuples **inherit from the tuple class**, so you get tuple-like behavior:
```python
isinstance(p1, tuple)  # True
```

### 🔄 Field Access:
Named tuples allow access to fields via **dot notation** as well as **indexing**:
```python
p1.x  # 10
p1[0]  # 10
```

---

## 🔄 Comparison: Named Tuples vs Classes

### Named Tuples: Get Freebies 🆓

Named tuples provide many things **for free** that you’d have to manually code in a class:
1. **Equality checks**:
   ```python
   p1 = Point2D(10, 20)
   p2 = Point2D(10, 20)
   p1 == p2  # True
   ```
2. **Immutability**: Once created, values can't be changed.
3. **Iteration**: Named tuples are iterable, which means you can do things like:
   ```python
   max(p1)  # Returns the largest value, i.e., 20
   ```

### Classes: Need More Code

If you wrote your own class, you'd have to manually implement methods like:
- **`__repr__`** for pretty printing.
- **`__eq__`** for equality comparisons.

---

## 🧠 Named Tuples: Behind the Scenes

### Aliases 🎭:
Named tuples are **tuples**, and you can alias them too:
```python
Vector3D = namedtuple('Vector3D', ['x', 'y', 'z'])
```
However, always try to keep variable names consistent for clarity!

### Parameter Names Match Field Names 📝:
Named tuples allow passing values by **name**, just like a class:
```python
p1 = Point2D(x=10, y=20)
```

---

## ⚡ Useful Operations with Named Tuples

### 🧮 Dot Product Example

Suppose we have **two 2D points** and we want to calculate their **dot product** (i.e., multiply corresponding components and sum them):
```python
a = Point2D(1, 2)
b = Point2D(1, 1)

dot_product = a.x * b.x + a.y * b.y  # 1*1 + 2*1 = 3
```

### 🔢 Tuple Behavior:
You can even **zip** named tuples and perform operations on them:
```python
a = (1, 2)
b = (1, 1)
result = sum(x * y for x, y in zip(a, b))  # 3
```

### 3D Example with Named Tuples:
You can do the same with **3D vectors**:
```python
Vector3D = namedtuple('Vector3D', ['x', 'y', 'z'])
v1 = Vector3D(1, 2, 3)
v2 = Vector3D(1, 1, 1)

dot_product = v1.x * v2.x + v1.y * v2.y + v1.z * v2.z  # 6
```

---

## 🛠️ Slicing and Access

Named tuples allow **slicing** like regular tuples:
```python
v1[:2]  # (1, 2) - first two components
```
Access elements either by **index** or by **name** for greater flexibility.

---

## 🚀 Conclusion

Named tuples features:
- Save you from writing repetitive code.
- Combine the best of **tuples** and **classes** with named fields.
- Make your code more readable and safe (immutability is great for avoiding accidental changes!).

They are ideal when you need simple, readable, and **immutable** data structures. ✨

---


# PART 2

## 🎯 Creating a `namedtuple`

Let’s create a `circle` using a `namedtuple`. Instead of remembering positions, we can assign names to elements:

```python
from collections import namedtuple
Circle = namedtuple('Circle', 'centerX centerY radius')
c = Circle(0, 0, 10)
```

- Now, `c.centerX`, `c.centerY`, and `c.radius` give us the values.  
- Named tuples allow dot notation just like classes. 

### 🎓 Example:
```python
c.radius  # Output: 10
```

## 🚀 Flexibility with Whitespace

You can use different whitespace formats in your `namedtuple` field names:
```python
Stock = namedtuple('Stock', 'symbol year month day open high low close')
```

### 📝 Example:
```python
DJIA = Stock("Dow Jones", 2018, 4, 25, 26313, 26458, 26260, 26393)
```

## 🛠 Unpacking Named Tuples

You can easily unpack named tuples:
```python
symbol, year, month, day, *_, close = DJIA
```

Here:
- `_` is a placeholder for unwanted values.
- `close` will hold the closing value (26,393).

## ⚠️ Field Name Restrictions

Named tuples don’t allow field names starting with underscores (`_`), but regular classes do!  
To handle invalid field names, you can use the `rename=True` argument. This replaces invalid names automatically.

### 💡 Example:
```python
Person = namedtuple('Person', 'name age _ssn', rename=True)
```
This will rename `_ssn` to `_1` and avoid conflicts.

## 🧩 Viewing Fields

You can inspect field names with `.fields`:
```python
DJIA._fields  # Output: ('symbol', 'year', 'month', 'day', 'open', 'high', 'low', 'close')
```

## 🔍 Introspection

You can view the underlying class source code using `_source`:
```python
print(Stock._source)
```
This shows how the `namedtuple` is dynamically created, making use of properties and methods like:
- `__new__`
- `__repr__`
- `.replace()`
- `.asdict()`

## 📑 Converting to Dictionaries

Named tuples can be converted into dictionaries using `asdict()`:
```python
DJIA_dict = DJIA._asdict()  # Outputs an OrderedDict
```

- **OrderedDict** ensures key order is maintained.  
- In Python 3.6+, even normal dictionaries maintain order by default. 🎉

## ⏳ Efficiency of Named Tuples

There’s **minimal overhead** with named tuples! ⚡
- Field names are stored in the **class**, not the instance.
- Instances are **tuples** underneath, so performance is close to normal tuples.

If you access fields via dot notation (`x.y`), it’s still efficient. 🏎  
Accessing values using `.x` or `.y` will retrieve values similar to how you'd do it in a class property.