#python #pythonVersion

---
## ğŸ“‹ Disclaimer
- This video won't cover **all** the changes in Python 3.10, just the **most useful** and **interesting** ones.
- Improved **syntax error messaging** is now a feature! Errors should give you **better hints** about whatâ€™s wrong with your code ğŸ§.

## ğŸ¯ Key Feature: **Structural Pattern Matching**

Python 3.10 introduces a new language feature called **Pattern Matching**â€”an enhancement over the traditional `if-elif` structures. This is **way beyond** a regular `switch` statement in other languages!

### ğŸ“ **Syntax Overview**:
```python
def respond(language):
    match language:
        case "Java":
            return "â˜• Coffee?"
        case "Python":
            return "ğŸ I'm not scared of snakes!"
        case "Go":
            return "Collect $200 ğŸ¦ (Monopoly reference)"
        case _:
            return "ğŸ¤·â€â™‚ï¸ Sorry!"
```

- The `match` statement checks for cases, and `_` acts as the **default case**.
- You can now avoid using `if-elif` chains for simple pattern matching!

### ğŸ§‘â€ğŸ’» **Example**:
```python
respond("Java")  # Outputs: â˜• Coffee?
respond("COBOL") # Outputs: ğŸ¤·â€â™‚ï¸ Sorry!
```

### ğŸ”¥ **Multiple Matches**:
You can match **multiple cases** with a single line using `|` (pipe).
```python
match language:
    case "Java" | "JavaScript":
        return "â˜•â˜• Double shot of coffee!"
```

---

## ğŸ® Advanced Pattern Matching: **Command Matching for a Robot** ğŸ¤–

Imagine programming a robot to move through a maze. Our robot can:
- Move forward (`move f`), backward (`move b`), left (`move l`), or right (`move r`).
- Pick up (`pick`) or drop items (`drop`).

### ğŸ› ï¸ **Pattern Matching Commands**:
```python
def process_command(command):
    match command:
        case ("move", direction):
            return f"ğŸš¶ Moving {direction}"
        case ("pick"):
            return "ğŸ¤– Picking up item"
        case ("drop"):
            return "ğŸ¤– Dropping item"
        case _:
            return "âŒ Command not supported!"
```

### ğŸ”— **Command Example**:
```python
process_command(("move", "f"))  # Outputs: ğŸš¶ Moving f
process_command(("pick"))       # Outputs: ğŸ¤– Picking up item
```

---

## ğŸ§  **Using Guards in Pattern Matching**:
Guards allow you to add **conditional checks** to your pattern matching cases.

```python
match command:
    case ("move", direction) if direction in {"f", "b", "l", "r"}:
        return f"Moving in direction: {direction}"
    case _:
        return "Invalid command!"
```

### ğŸ¤” **Explanation**:
- `if direction in {"f", "b", "l", "r"}`: This ensures that only valid directions (forward, backward, left, right) are processed.

---

## ğŸ‰ **Better Command Handling**:
Pattern matching makes handling **complex commands** a breeze. Instead of repeating yourself, use lists!

```python
commands = [
    ("move", "f"),
    ("pick"),
    ("move", "r"),
    ("drop")
]
for command in commands:
    process_command(command)
```

### ğŸ’¡ **Result**:
- ğŸš¶ Moving forward
- ğŸ¤– Picking up item
- ğŸš¶ Moving right
- ğŸ¤– Dropping item

---

## ğŸ§‘â€ğŸ”§ **Pythonâ€™s `zip` Functionality: Extended** âš¡

The `zip()` function stops at the **shortest** iterable:
```python
l1 = ["A", "B", "C"]
l2 = [10, 20, 30, 40]
list(zip(l1, l2))  # Outputs: [('A', 10), ('B', 20), ('C', 30)]
```

### â• **Using `itertools.zip_longest()`**:
If you want to continue until the longest iterable, use `zip_longest()`:
```python
from itertools import zip_longest
list(zip_longest(l1, l2, fillvalue='???'))
# Outputs: [('A', 10), ('B', 20), ('C', 30), (None, 40)]
```

Fill in the missing values with the **fillvalue**!

---

## ğŸ“š **Further Reading**:
For more on **pattern matching**:
- ğŸ”— [PEP 636: Structural Pattern Matching](https://peps.python.org/pep-0636/)
- ğŸ“„ Check out the **Jupyter Notebook** in the GitHub repo for **examples** and **links**.


---
## Zip and Zip Longest in Python ğŸš€

### 1. Overview of `zip` and `zip_longest` ğŸ› ï¸
- **`zip()`**: Pairs elements from multiple iterables, stopping when the **shortest** iterable is exhausted.
- **`zip_longest()`**: Zips until the **longest** iterable is exhausted, filling missing values with a specified default value.

### 2. Handling Unequal Length Iterables â—
- **Problem**: `zip()` doesn't ensure iterables are of the same length. When zipping unequal-length iterables, it stops at the shorter one.
- **Potential Issue**: No error is raised if the iterables are of different lengths. You might assume they're the same, but theyâ€™re not.
  
### Example: ğŸš¨
```python
L1 = (i**2 for i in range(4))  # [0, 1, 4, 9]
L2 = (i**3 for i in range(3))  # [0, 1, 8]
list(zip(L1, L2))  # [(0, 0), (1, 1), (4, 8)]
```
In this case, `zip()` stops after 3 pairs even though `L1` has 4 elements. The **4th element** in `L1` is not zipped.

---

### 3. Exhausting Iterators Problem ğŸ’¡
- **Checking length** of iterators or generators is tricky. Doing this will **exhaust them**, making them unusable afterward.
  
### Example:
```python
L1 = (i**2 for i in range(4))
L2 = (i**3 for i in range(3))

len(list(L1)) == len(list(L2))  # False
```
After this check, `L1` and `L2` are now **empty** and can't be reused for iteration. ğŸ˜µâ€ğŸ’«

---

### 4. Python 3.10 Solution: `strict=True` ğŸ›¡ï¸
Python 3.10 introduced a **`strict`** argument for `zip`! When set to `True`, it raises a **ValueError** if the iterables are not of the same length. This helps to ensure that the iterables are zipped correctly without manually checking their lengths.

### Example: ğŸ’¥
```python
L1 = (i**2 for i in range(4))
L2 = (i**3 for i in range(3))

result = zip(L1, L2, strict=True)
list(result)  # Raises ValueError: zip() argument 2 is longer than argument 1
```

- âš ï¸ **Note**: The exception is raised only when you **iterate** through the result (lazy evaluation).

---

### 5. Why Use `strict=True`? ğŸ¤”
- In most cases, when zipping, you expect the iterables to be of the **same length**.
- Using `strict=True` ensures:
  - Code robustness ğŸ§‘â€ğŸ’»
  - Quick detection of mismatches âš–ï¸
  - Avoids silent bugs ğŸ”

Without `strict=True`, you'd need to manually convert iterators to lists, compare their lengths, and raise an exception yourself.

---

## Summary ğŸ“
- `zip()` stops at the shortest iterable by default, while `zip_longest()` continues to the longest.
- **Problem**: Pre-checking length of iterators **exhausts them**, causing issues.
- **Solution**: Use **Python 3.10+** with `strict=True` to automatically enforce equal lengths in zipping.
- This makes your code **cleaner**, **more reliable**, and **safer** when working with iterables.